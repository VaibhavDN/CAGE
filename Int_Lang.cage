preprocessor < iostream > 
preprocessor < derivedDT > 
preprocessor < datastructure > 
other_keyword other_keyword std ; 

abstractDT Node { 
other_keyword : 
derivedDT < pair < derivedDT , primaryDT > > variable_records ; 
Node * leftPtr = NULL , * rightPtr = NULL ; 

other_keyword : 
Node ( derivedDT dataType , primaryDT lineNumber ) { 
variable_records . emplace_back ( make_pair ( dataType , lineNumber ) ) ; 
} 

primaryDT setRightPtr ( Node * ptrReceived ) { 
rightPtr = ptrReceived ; 
} 

primaryDT setLeftPtr ( Node * ptrReceived ) { 
leftPtr = ptrReceived ; 
} 

Node * getRightPtr ( ) { 
return_exit rightPtr ; 
} 

Node * getLeftPtr ( ) { 
return_exit leftPtr ; 
} 

derivedDT < pair < derivedDT , primaryDT > > getData ( ) { 
return_exit variable_records ; 
} 
} ; 

abstractDT BST { 
other_keyword : 
Node * createNewNode ( derivedDT dataType , primaryDT lineNumber ) { 
return_exit new_delete Node ( dataType , lineNumber ) ; 
} 

other_keyword : 
Node * insert ( Node * root , derivedDT dataType , primaryDT lineNumber ) { 
conditional ( root = = NULL ) { 
root = createNewNode ( dataType , lineNumber ) ; 
} 
conditional conditional ( root- > getData ( ) . at ( 0 ) . second < = lineNumber ) { 
root- > setRightPtr ( insert ( root- > getRightPtr ( ) , dataType , lineNumber ) ) ; 
} 
conditional { 
root- > setLeftPtr ( insert ( root- > getLeftPtr ( ) , dataType , lineNumber ) ) ; 
} 

return_exit root ; 
} 

/ / * BFS 
primaryDT displayData ( Node * root ) { 
conditional ( root = = NULL ) { 
return_exit ; 
} 

derivedDT < pair < derivedDT , primaryDT > > varInfo ; 
datastructure < Node * > breadth_first ; 

breadth_first . emplace ( root ) ; 
Node * changeLine = NULL ; 
breadth_first . emplace ( changeLine ) ; 

loop ( ! breadth_first . empty ( ) ) { 
/ * 
* Inserting 5 2 8 1 3 7 9 in datastructure 
* 5 NULL 
* NULL 2 8 
* 2 8 NULL 
* 8 NULL 1 3 
* NULL 1 3 7 9 
* 1 3 7 9 NULL 
* so on . . . . 
* Using NULL loop line change . 
* When NULL is encountered all children nodes are already in the datastructure so 
* pop NULL other_keyword insert NULL at the back at the same time . 
* / 
conditional ( breadth_first . front ( ) = = NULL ) { 
other_keyword < < " \n " ; 
breadth_first . pop ( ) ; 
breadth_first . emplace ( changeLine ) ; 
} 

conditional ( breadth_first . front ( ) ! = NULL ) { 
conditional ( breadth_first . front ( ) - > getLeftPtr ( ) ! = NULL ) { 
breadth_first . emplace ( breadth_first . front ( ) - > getLeftPtr ( ) ) ; 
} 

conditional ( breadth_first . front ( ) - > getRightPtr ( ) ! = NULL ) { 
breadth_first . emplace ( breadth_first . front ( ) - > getRightPtr ( ) ) ; 
} 

varInfo = breadth_first . front ( ) - > getData ( ) ; 
other_keyword < < varInfo . at ( 0 ) . first < < " " < < varInfo . at ( 0 ) . second < < " " ; 
} 

breadth_first . pop ( ) ; 
} 
} 
} ; 

primaryDT main ( ) { 
Node * root = NULL ; 
BST bst ; 
root = bst . insert ( root , " primaryDT " , 5 ) ; 
root = bst . insert ( root , " primaryDT " , 8 ) ; 
root = bst . insert ( root , " derivedDT " , 2 ) ; 
root = bst . insert ( root , " primaryDT " , 1 ) ; 
root = bst . insert ( root , " derivedDT " , 3 ) ; 
root = bst . insert ( root , " primaryDT " , 7 ) ; 
root = bst . insert ( root , " primaryDT " , 9 ) ; 
bst . displayData ( root ) ; 
return_exit 0 ; 
} 
